"""
Use cases for document management.
"""

from uuid import UUID, uuid4

from src.application.dtos.document_dto import (
    DocumentChunkResponse,
    DocumentSearchRequest,
    DocumentUploadRequest,
    DocumentUploadResponse,
)
from src.application.dtos.entity_dto import EntityExtractionRequest
from src.application.use_cases.entity_extraction_use_case import (
    EntityExtractionUseCase,
)
from src.domain.entities.document import Document
from src.domain.repositories.document_repository import IDocumentRepository
from src.infrastructure.document_processing.document_processor import DocumentProcessor
from src.infrastructure.embeddings.embedding_service import EmbeddingService
from src.shared.exceptions import UseCaseExecutionError
from src.shared.logging import LoggerMixin


class UploadDocumentUseCase(LoggerMixin):
    """Use case for uploading and processing documents."""

    def __init__(
        self,
        document_repo: IDocumentRepository,
        embedding_service: EmbeddingService,
        document_processor: DocumentProcessor,
        entity_extraction_use_case: EntityExtractionUseCase | None = None,
    ) -> None:
        self.document_repo = document_repo
        self.embedding_service = embedding_service
        self.document_processor = document_processor
        self.entity_extraction_use_case = entity_extraction_use_case

    async def execute(
        self, request: DocumentUploadRequest, file_content: bytes, filename: str
    ) -> DocumentUploadResponse:
        """
        Upload and process a document.

        Args:
            request: Document upload request
            file_content: Raw file bytes
            filename: Original filename

        Returns:
            Document upload response

        Raises:
            UseCaseExecutionError: If upload fails
        """
        try:
            self.logger.info(
                "uploading_document",
                filename=filename,
                user_id=request.user_id,
                size_bytes=len(file_content),
            )

            # Step 1: Extract text from document
            text_content = self.document_processor.extract_text(file_content, filename)

            # Step 2: Generate file hash for deduplication
            file_hash = self.document_processor.get_file_hash(file_content)

            # Step 3: Check if document already exists
            existing = await self.document_repo.get_by_hash(file_hash, request.user_id)
            if existing:
                self.logger.warning(
                    "document_already_exists",
                    file_hash=file_hash,
                    existing_doc_id=str(existing[0].doc_id),
                )
                raise UseCaseExecutionError(
                    f"Document already uploaded: {existing[0].path}",
                    details={"existing_doc_id": str(existing[0].doc_id)},
                )

            # Step 4: Chunk the text
            chunks = self.document_processor.chunk_text(
                text_content,
                metadata={
                    "user_id": request.user_id,
                    "title": request.title,
                    "filename": filename,
                    "file_hash": file_hash,
                },
            )

            # Step 5: Generate document ID
            doc_id = uuid4()

            # Step 6: Process and store each chunk
            total_chars = 0
            for i, chunk_data in enumerate(chunks):
                # Generate embedding for chunk
                embedding = await self.embedding_service.embed_text(chunk_data["content"])

                # Create document entity
                document = Document(
                    doc_id=doc_id,
                    user_id=request.user_id,
                    chunk_id=chunk_data["chunk_id"],  # UUID generated by processor
                    path=request.title,
                    content=chunk_data["content"],
                    tags=request.tags,
                    embedding=embedding,
                    metadata={
                        "filename": filename,
                        "file_hash": file_hash,
                        "chunk_hash": chunk_data["chunk_hash"],
                        "chunk_index": i,
                        "total_chunks": len(chunks),
                        "start_char": chunk_data["start_char"],
                        "end_char": chunk_data["end_char"],
                        **request.metadata,
                    },
                )

                # Store in repository
                await self.document_repo.create(document)

                total_chars += len(chunk_data["content"])

            self.logger.info(
                "document_uploaded",
                doc_id=str(doc_id),
                num_chunks=len(chunks),
                total_chars=total_chars,
            )

            # Step 7: Extract entities from document if use case is available
            entities_created = 0
            relationships_created = 0
            if self.entity_extraction_use_case:
                try:
                    extraction_request = EntityExtractionRequest(
                        text=text_content,
                        user_id=request.user_id,
                        source="document",
                        metadata={
                            "doc_id": str(doc_id),
                            "filename": filename,
                            "title": request.title,
                        },
                    )
                    extraction_response = await self.entity_extraction_use_case.execute(
                        extraction_request
                    )
                    entities_created = extraction_response.num_entities_created
                    relationships_created = extraction_response.num_relationships_created

                    self.logger.info(
                        "entities_extracted_from_document",
                        doc_id=str(doc_id),
                        entities_created=entities_created,
                        relationships_created=relationships_created,
                    )
                except Exception as e:
                    self.logger.error(
                        "document_entity_extraction_failed",
                        doc_id=str(doc_id),
                        error=str(e),
                    )
                    # Don't fail upload if entity extraction fails

            return DocumentUploadResponse(
                doc_id=doc_id,
                title=request.title,
                num_chunks=len(chunks),
                total_characters=total_chars,
                tags=request.tags,
            )

        except UseCaseExecutionError:
            raise
        except Exception as e:
            self.logger.error("document_upload_failed", error=str(e), filename=filename)
            raise UseCaseExecutionError(
                f"Failed to upload document: {str(e)}"
            ) from e


class SearchDocumentsUseCase(LoggerMixin):
    """Use case for searching documents."""

    def __init__(
        self,
        document_repo: IDocumentRepository,
        embedding_service: EmbeddingService,
    ) -> None:
        self.document_repo = document_repo
        self.embedding_service = embedding_service

    async def execute(
        self, request: DocumentSearchRequest
    ) -> list[tuple[DocumentChunkResponse, float]]:
        """
        Search for document chunks.

        Args:
            request: Document search request

        Returns:
            List of (DocumentChunkResponse, similarity_score) tuples

        Raises:
            UseCaseExecutionError: If search fails
        """
        try:
            self.logger.info(
                "searching_documents",
                query=request.query[:50],
                user_id=request.user_id,
                limit=request.limit,
            )

            # Generate embedding for query
            query_embedding = await self.embedding_service.embed_query(request.query)

            # Search in repository
            results = await self.document_repo.search_similar(
                query_embedding=query_embedding,
                user_id=request.user_id,
                limit=request.limit,
                min_score=request.min_score,
                tags=request.tags,
            )

            self.logger.info("documents_found", count=len(results))

            # Convert to responses
            responses = []
            for doc, score in results:
                response = DocumentChunkResponse(
                    doc_id=doc.doc_id,
                    chunk_id=doc.chunk_id,
                    path=doc.path,
                    content=doc.content,
                    tags=doc.tags,
                    chunk_index=doc.metadata.get("chunk_index", 0),
                    total_chunks=doc.metadata.get("total_chunks", 1),
                )
                responses.append((response, score))

            return responses

        except Exception as e:
            self.logger.error("document_search_failed", error=str(e))
            raise UseCaseExecutionError(
                f"Failed to search documents: {str(e)}"
            ) from e


class DeleteDocumentUseCase(LoggerMixin):
    """Use case for deleting a document and all its chunks."""

    def __init__(self, document_repo: IDocumentRepository) -> None:
        self.document_repo = document_repo

    async def execute(self, doc_id: UUID, user_id: str) -> bool:
        """
        Delete a document and all its chunks.

        Args:
            doc_id: Document identifier
            user_id: User ID for authorization

        Returns:
            True if deleted, False if not found

        Raises:
            UseCaseExecutionError: If deletion fails
        """
        try:
            self.logger.info("deleting_document", doc_id=str(doc_id), user_id=user_id)

            # Delete all chunks of the document
            deleted = await self.document_repo.delete_by_doc_id(doc_id, user_id)

            if deleted > 0:
                self.logger.info(
                    "document_deleted", doc_id=str(doc_id), chunks_deleted=deleted
                )
                return True
            else:
                self.logger.warning(
                    "document_not_found", doc_id=str(doc_id), user_id=user_id
                )
                return False

        except Exception as e:
            self.logger.error("document_deletion_failed", doc_id=str(doc_id), error=str(e))
            raise UseCaseExecutionError(
                f"Failed to delete document: {str(e)}"
            ) from e
